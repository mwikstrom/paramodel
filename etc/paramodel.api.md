## API Report File for "paramodel"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Type } from 'paratype';
import { TypeOf } from 'paratype';

// @public (undocumented)
export interface ActionContext<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> {
    // (undocumented)
    conflict(message?: string): never;
    // (undocumented)
    emit<K extends string & keyof Events>(key: K, arg: TypeOf<Events[K]>): void;
    // (undocumented)
    forbidden(message?: string): never;
    // (undocumented)
    readonly input: Input;
    // (undocumented)
    output(result: Output): void;
    // (undocumented)
    readonly scope: Scope;
    // (undocumented)
    readonly timestamp: Date;
    // (undocumented)
    readonly version: number;
    // (undocumented)
    view: ViewSnapshotFunc<Views>;
}

// @public (undocumented)
export type ActionFunc<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> = (context: ActionContext<Events, Views, Scope, Input, Output>) => Promise<void>;

// @public (undocumented)
export interface ActionHandler<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> {
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof Views>;
    // (undocumented)
    readonly exec: ActionFunc<Events, Views, Scope, Input, Output>;
    // (undocumented)
    readonly input: Type<Input>;
    // (undocumented)
    readonly output: Type<Output>;
}

// @public (undocumented)
export interface ActionOptions {
    // (undocumented)
    dry?: boolean;
}

// @public (undocumented)
export interface ActionResult<Events extends ChangeModel, Output> {
    // (undocumented)
    readonly base: number;
    // (undocumented)
    readonly changes: readonly ChangeType<Events>[];
    // (undocumented)
    readonly committed?: number;
    // (undocumented)
    readonly message?: string;
    // (undocumented)
    readonly output?: Output;
    // (undocumented)
    readonly status: "success" | "conflict" | "forbidden";
    // (undocumented)
    readonly timestamp: Date;
}

// @public (undocumented)
export type ActionResultType<Model extends Pick<DomainModel, "actions" | "events">, Action extends string & keyof Model["actions"]> = (ActionResult<Model["events"], TypeOf<Model["actions"][Action]["output"]>>);

// @public (undocumented)
export type ArrayAnyOperator = ("includes-any" | "not-includes-any");

// @public (undocumented)
export type ArrayOperator = ("includes" | "not-includes" | ArrayAnyOperator);

// @public (undocumented)
export interface Change<K extends string = string, T = unknown> {
    // (undocumented)
    readonly arg: T;
    // (undocumented)
    readonly key: K;
    // (undocumented)
    readonly offset: number;
    // (undocumented)
    readonly timestamp: Date;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type ChangeModel<K extends string = string, T = unknown> = Readonly<Record<K, Type<T>>>;

// @public (undocumented)
export type ChangeType<Model extends ChangeModel> = {
    [K in keyof Model]: K extends string ? Change<K, TypeOf<Model[K]>> : never;
}[keyof Model];

// @public (undocumented)
export type Comparable = number | string | Date;

// @public (undocumented)
export type ComparisonOperator = ">" | ">=" | "<" | "<=";

// @public (undocumented)
export function defineAction<Events extends ChangeModel, Views extends ReadModel, Scope, Input, Output, Dependencies extends (string & keyof Views)[]>(input: Type<Input>, output: Type<Output>, dependencies: Dependencies, exec: ActionFunc<Events, Pick<Views, Dependencies[number]>, Scope, Input, Output>): ActionHandler<Events, Pick<Views, Dependencies[number]>, Scope, Input, Output>;

// @public (undocumented)
export function defineEntity<Events extends ChangeModel, Views extends ReadModel, Scope, Props extends Record<string, unknown>, Mutators extends string & keyof Events, Dependencies extends (string & keyof Views)[]>(type: Type<Props>, dependencies: Dependencies, on: {
    [K in Mutators]: EntityProjectionFunc<ChangeModel<K, Events[K]>, Pick<Views, Dependencies[number]>, Props>;
}, auth?: EntityAuthFunc<Scope, Props, Pick<Views, Dependencies[number]>>): EntityProjection<Props, Events, Views, Scope>;

// @public (undocumented)
export function defineQuery<Views extends ReadModel, Scope, Dependencies extends (string & keyof Views)[], Params extends Record<string, unknown>, Result>(type: Type<Result>, params: Type<Params>, dependencies: Dependencies, exec: QueryFunc<Pick<Views, Dependencies[number]>, Params, Scope, Result>): QueryHandler<Params, Result, Pick<Views, Dependencies[number]>, Scope>;

// @public (undocumented)
export function defineState<Events extends ChangeModel, Views extends ReadModel, Scope, State, Mutators extends string & keyof Events, Dependencies extends (string & keyof Views)[]>(type: Type<State>, initial: State, dependencies: Dependencies, on: {
    [K in Mutators]: StateApplyFunc<ChangeModel<K, Events[K]>, Pick<Views, Dependencies[number]>, State>;
}, auth?: StateAuthFunc<Scope, State, Pick<Views, Dependencies[number]>>): StateProjection<State, Events, Views, Scope>;

// @public (undocumented)
export type DomainModel<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Actions extends WriteModel = WriteModel, Scope = unknown> = {
    readonly events: Events;
    readonly views: Views;
    readonly actions: Actions;
    readonly scope: Type<Scope>;
};

// @public (undocumented)
export interface DomainStore<Model extends DomainModel> {
    // (undocumented)
    readonly changes: SortedQueryable<ChangeType<Model["events"]>>;
    // (undocumented)
    do<K extends string & keyof Model["actions"]>(key: K, input: TypeOf<Model["actions"][K]["input"]>, options?: ActionOptions): Promise<ActionResultType<Model, K>>;
    // (undocumented)
    view<K extends string & keyof Model["views"]>(key: K, options?: ViewOptions): Promise<ViewOf<Model["views"][K]> | undefined>;
}

// @public (undocumented)
export interface DomainStoreProvider {
    // (undocumented)
    get<Model extends DomainModel>(id: string, model: Model, scope: TypeOf<Model["scope"]>): DomainStore<Model>;
}

// @public (undocumented)
export type Entity<T extends Record<string, unknown> = Record<string, unknown>> = T & {
    id: number;
};

// @public (undocumented)
export type EntityAuthFunc<Scope, T extends Record<string, unknown> = Record<string, unknown>, R extends ReadModel = ReadModel> = (query: Filterable<T>, scope: Scope, view: ViewSnapshotFunc<R>) => Promise<Filterable<T> | Forbidden>;

// @public (undocumented)
export interface EntityCollection<T extends Record<string, unknown> = Record<string, unknown>> extends ReadonlyEntityCollection<T> {
    // (undocumented)
    del(id: number): void;
    // (undocumented)
    put(id: number, props: T): void;
}

// @public (undocumented)
export interface EntityProjection<T extends Record<string, unknown> = Record<string, unknown>, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly apply: EntityProjectionFunc<C, R, T>;
    // (undocumented)
    readonly auth: EntityAuthFunc<Scope, T, R> | undefined;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export type EntityProjectionFunc<C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, T extends Record<string, unknown> = Record<string, unknown>> = (change: ChangeType<C>, state: EntityCollection<T>, view: ViewSnapshotFunc<R>) => Promise<void>;

// @public (undocumented)
export interface EntityView<T extends Record<string, unknown> = Record<string, unknown>> extends ReadonlyEntityCollection<T> {
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type EqualityOperator = "==" | "!=" | "in" | "not-in";

// @public (undocumented)
export type Equatable = null | boolean | Comparable;

// @public (undocumented)
export interface Filterable<T> {
    // (undocumented)
    where<P extends string & keyof T, O extends FilterOperator<T[P]>>(property: P, operator: O, operand: FilterOperand<T[P], O>): Filtered<T>;
}

// @public (undocumented)
export type Filtered<T> = T extends Queryable<T> ? Queryable<T> : T extends SortedQueryable<T> ? SortedQueryable<T> : Filterable<T>;

// @public (undocumented)
export type FilterOperand<T, O> = (O extends IsOperator ? IsOperand<T> : O extends EqualityOperator ? T : O extends ComparisonOperator ? T : O extends ArrayAnyOperator ? T : O extends ArrayOperator ? T extends unknown[infer E] ? E : never : O extends StringOperator ? string : never);

// @public (undocumented)
export type FilterOperator<T> = ((IsOperand<T> extends never ? never : IsOperator) | (T extends Equatable ? EqualityOperator : never) | (T extends Comparable ? ComparisonOperator : never) | (T extends unknown[] ? ArrayOperator : never) | (T extends string ? StringOperator : never));

// @public (undocumented)
export const Forbidden: unique symbol;

// @public (undocumented)
export type Forbidden = typeof Forbidden;

// @public (undocumented)
export type IsOperand<T> = ((T extends undefined ? "defined" : never) | (T extends null ? "null" | "scalar" : never) | (T extends boolean ? "boolean" | "scalar" : never) | (T extends number ? "number" | "scalar" : never) | (T extends string ? "string" | "scalar" : never) | (T extends unknown[] ? "array" : never) | (T extends Record<string, unknown> ? "object" : never));

// @public (undocumented)
export type IsOperator = "is" | "is-not";

// @public (undocumented)
export interface ModelBuilder<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Actions extends WriteModel = WriteModel, Scope = unknown> {
    // (undocumented)
    addAction<ActionKey extends string, Handler extends ActionHandler>(key: ActionKey, handler: Handler): ModelBuilder<Events, Views, Actions & WriteModel<ActionKey, ActionHandler>, Scope>;
    // (undocumented)
    addEvent<EventKey extends string, EventArg>(key: EventKey, type: Type<EventArg>): ModelBuilder<Events & ChangeModel<EventKey, EventArg>, Views, Actions, Scope>;
    // (undocumented)
    addView<ViewKey extends string, Handler extends Projection>(key: ViewKey, handler: Handler): ModelBuilder<Events, Views & ReadModel<ViewKey, Handler>, Actions, Scope>;
    // (undocumented)
    createModel(): DomainModel<Events, Views, Actions, Scope>;
}

// @public (undocumented)
export interface Page<T> {
    // (undocumented)
    readonly continuation?: string;
    // (undocumented)
    readonly final?: boolean;
    // (undocumented)
    readonly items: readonly T[];
}

// @public (undocumented)
export interface PageOptions {
    // (undocumented)
    continuation?: string;
    // (undocumented)
    fill?: boolean;
    // (undocumented)
    size?: number;
}

// @public (undocumented)
export type Projection = StateProjection | QueryHandler | EntityProjection;

// @public (undocumented)
export interface Queryable<T> extends SortedQueryable<T> {
    // (undocumented)
    by<P extends keyof SortableProps<T>>(property: P): SortedQueryable<T>;
}

// @public (undocumented)
export type QueryFunc<R extends ReadModel = ReadModel, P extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, T = unknown> = (view: ViewSnapshotFunc<R>, params: P, scope: Scope) => Promise<T | Forbidden>;

// @public (undocumented)
export interface QueryHandler<P extends Record<string, unknown> = Record<string, unknown>, T = unknown, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly exec: QueryFunc<R, P, Scope, T>;
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    readonly params: Type<P>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export interface QueryView<P = unknown, T = unknown> {
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    query(params: P): T;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type ReadModel<K extends string = string, T extends Projection = Projection> = Readonly<Record<K, T>>;

// @public (undocumented)
export interface ReadonlyEntityCollection<T extends Record<string, unknown> = Record<string, unknown>> extends Queryable<Entity<T>> {
    // (undocumented)
    get(id: number): Promise<Entity<T> | undefined>;
}

// @public (undocumented)
export type SortableProps<T> = {
    [P in keyof T]: T[P] extends Comparable ? T[P] : never;
};

// @public (undocumented)
export interface SortedQueryable<T> extends Filterable<T>, AsyncIterable<T> {
    // (undocumented)
    any(): Promise<boolean>;
    // (undocumented)
    count(): Promise<number>;
    // (undocumented)
    first(): Promise<T | undefined>;
    // (undocumented)
    page(options?: PageOptions): Promise<Page<T>>;
}

// @public (undocumented)
export type StateApplyFunc<C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, T = unknown> = (this: void, change: ChangeType<C>, before: T, view: ViewSnapshotFunc<R>) => Promise<T>;

// @public (undocumented)
export type StateAuthFunc<Scope = unknown, T = unknown, R extends ReadModel = ReadModel> = (this: void, scope: Scope, state: T, view: ViewSnapshotFunc<R>) => Promise<T | Forbidden>;

// @public (undocumented)
export interface StateProjection<T = unknown, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly apply: StateApplyFunc<C, R, T>;
    // (undocumented)
    readonly auth: StateAuthFunc<Scope, T, R> | undefined;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly initial: T;
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export interface StateView<T = unknown> {
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    read(): Promise<T>;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type StringOperator = ("contains" | "contains-ignore-case" | "starts-with" | "starts-with-ignore-case" | "ends-with" | "ends-with-ignore-case");

// @public (undocumented)
export type VersionAlignment<T> = (T extends number ? ("exact" | "fresh-after" | "fresh-before") : ("latest" | "latest-fresh"));

// @public (undocumented)
export type View = StateView | QueryView | EntityView;

// @public (undocumented)
export type ViewOf<H extends Projection> = H extends StateProjection<infer T> ? StateView<T> : H extends QueryHandler<infer P, infer T> ? QueryView<P, T> : H extends EntityProjection<infer T> ? EntityView<T> : View;

// @public (undocumented)
export interface ViewOptions<T extends number | undefined = undefined> {
    // (undocumented)
    readonly align?: VersionAlignment<T>;
    // (undocumented)
    readonly version?: T;
}

// @public (undocumented)
export type ViewSnapshotFunc<R extends ReadModel> = <K extends string & keyof R>(key: K) => Promise<ViewOf<R[K]>>;

// @public (undocumented)
export type WriteModel<K extends string = string, T extends ActionHandler = ActionHandler> = Readonly<Record<K, T>>;

```

## API Report File for "paramodel"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Type } from 'paratype';
import { TypeOf } from 'paratype';

// @public (undocumented)
export interface ActionContext<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Input = unknown, Output = unknown> {
    // (undocumented)
    conflict(message: string): never;
    // (undocumented)
    emit<K extends string & keyof Events>(key: K, arg: TypeOf<Events[K]>): void;
    // (undocumented)
    readonly input: Input;
    // (undocumented)
    output(result: Output): void;
    // (undocumented)
    readonly timestamp: Date;
    // (undocumented)
    readonly version: number;
    // (undocumented)
    view: ViewSnapshot<Views>;
}

// @public (undocumented)
export type ActionFunc<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Input = unknown, Output = unknown> = (context: ActionContext<Events, Views, Input, Output>) => Promise<void>;

// @public (undocumented)
export interface ActionHandler<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Input = unknown, Output = unknown> {
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof Views>;
    // (undocumented)
    readonly exec: ActionFunc<Events, Views, Input, Output>;
    // (undocumented)
    readonly input: Type<Input>;
    // (undocumented)
    readonly output: Type<Output>;
}

// @public (undocumented)
export interface ActionOptions {
    // (undocumented)
    dry?: boolean;
}

// @public (undocumented)
export interface ActionResult<Events extends ChangeModel, Output> {
    // (undocumented)
    readonly base: number;
    // (undocumented)
    readonly changes: readonly ChangeType<Events>[];
    // (undocumented)
    readonly committed?: number;
    // (undocumented)
    readonly conflict?: string;
    // (undocumented)
    readonly output?: Output;
    // (undocumented)
    readonly success: boolean;
    // (undocumented)
    readonly timestamp: Date;
}

// @public (undocumented)
export type ActionResultType<Model extends Pick<DomainModel, "actions" | "events">, Action extends string & keyof Model["actions"]> = (ActionResult<Model["events"], TypeOf<Model["actions"][Action]["output"]>>);

// @public (undocumented)
export type ArrayAnyOperator = ("includes-any" | "not-includes-any");

// @public (undocumented)
export type ArrayOperator = ("includes" | "not-includes" | ArrayAnyOperator);

// @public (undocumented)
export interface Change<K extends string = string, T = unknown> {
    // (undocumented)
    readonly arg: T;
    // (undocumented)
    readonly key: K;
    // (undocumented)
    readonly offset: number;
    // (undocumented)
    readonly timestamp: Date;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type ChangeModel<K extends string = string, T = unknown> = Readonly<Record<K, Type<T>>>;

// @public (undocumented)
export type ChangeType<Model extends ChangeModel> = {
    [K in keyof Model]: K extends string ? Change<K, TypeOf<Model[K]>> : never;
}[keyof Model];

// @public (undocumented)
export type Comparable = number | string | Date;

// @public (undocumented)
export type ComparisonOperator = ">" | ">=" | "<" | "<=";

// @public (undocumented)
export function defineAction<Events extends ChangeModel, Views extends ReadModel, Input, Output, Dependencies extends (string & keyof Views)[]>(input: Type<Input>, output: Type<Output>, dependencies: Dependencies, exec: ActionFunc<Events, Pick<Views, Dependencies[number]>, Input, Output>): ActionHandler<Events, Pick<Views, Dependencies[number]>, Input, Output>;

// @public (undocumented)
export function defineEntity<Events extends ChangeModel, Views extends ReadModel, Props extends Record<string, unknown>, Mutators extends (string & keyof Events)[], Dependencies extends (string & keyof Views)[]>(type: Type<Props>, mutators: Mutators, dependencies: Dependencies, apply: EntityProjectionFunc<Pick<Events, Mutators[number]>, Pick<Views, Dependencies[number]>, Props>): EntityProjection<Props, Pick<Events, Mutators[number]>, Pick<Views, Dependencies[number]>>;

// @public (undocumented)
export function defineQuery<Views extends ReadModel, Dependencies extends (string & keyof Views)[], Params extends Record<string, unknown>, Result>(type: Type<Result>, params: Type<Params>, dependencies: Dependencies, exec: QueryFunc<Pick<Views, Dependencies[number]>, Params, Result>): QueryHandler<Params, Result, Pick<Views, Dependencies[number]>>;

// @public (undocumented)
export function defineState<Events extends ChangeModel, Views extends ReadModel, State, Mutators extends string & keyof Events, Dependencies extends (string & keyof Views)[]>(type: Type<State>, initial: State, dependencies: Dependencies, on: {
    [K in Mutators]: StateApplyFunc<ChangeModel<K, Events[K]>, Pick<Views, Dependencies[number]>, State>;
}): StateProjection<State, Events, Views>;

// @public (undocumented)
export type DomainModel<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Actions extends WriteModel = WriteModel> = {
    readonly events: Events;
    readonly views: Views;
    readonly actions: Actions;
};

// @public (undocumented)
export interface DomainStore<Model extends DomainModel> {
    // (undocumented)
    readonly changes: SortedQueryable<ChangeType<Model["events"]>>;
    // (undocumented)
    do<K extends string & keyof Model["actions"]>(key: K, input: TypeOf<Model["actions"][K]["input"]>, options?: ActionOptions): Promise<ActionResultType<Model, K>>;
    // (undocumented)
    view<K extends string & keyof Model["views"]>(key: K, options?: ViewOptions): Promise<ViewOf<Model["views"][K]> | undefined>;
}

// @public (undocumented)
export interface DomainStoreProvider {
    // (undocumented)
    get<Model extends DomainModel>(id: string, model: Model): DomainStore<Model>;
}

// @public (undocumented)
export type Entity<T extends Record<string, unknown> = Record<string, unknown>> = T & {
    id: number;
};

// @public (undocumented)
export interface EntityCollection<T extends Record<string, unknown> = Record<string, unknown>> extends ReadonlyEntityCollection<T> {
    // (undocumented)
    del(id: number): void;
    // (undocumented)
    put(id: number, props: T): void;
}

// @public (undocumented)
export interface EntityProjection<T extends Record<string, unknown> = Record<string, unknown>, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel> {
    // (undocumented)
    readonly apply: EntityProjectionFunc<C, R, T>;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export type EntityProjectionFunc<C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, T extends Record<string, unknown> = Record<string, unknown>> = (change: ChangeType<C>, state: EntityCollection<T>, view: ViewSnapshot<R>) => Promise<void>;

// @public (undocumented)
export interface EntityView<T extends Record<string, unknown> = Record<string, unknown>> extends ReadonlyEntityCollection<T> {
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type EqualityOperator = "==" | "!=" | "in" | "not-in";

// @public (undocumented)
export type Equatable = null | boolean | Comparable;

// @public (undocumented)
export type FilterOperand<T, O> = (O extends IsOperator ? IsOperand<T> : O extends EqualityOperator ? T : O extends ComparisonOperator ? T : O extends ArrayAnyOperator ? T : O extends ArrayOperator ? T extends unknown[infer E] ? E : never : O extends StringOperator ? string : never);

// @public (undocumented)
export type FilterOperator<T> = ((IsOperand<T> extends never ? never : IsOperator) | (T extends Equatable ? EqualityOperator : never) | (T extends Comparable ? ComparisonOperator : never) | (T extends unknown[] ? ArrayOperator : never) | (T extends string ? StringOperator : never));

// @public (undocumented)
export type IsOperand<T> = ((T extends undefined ? "defined" : never) | (T extends null ? "null" | "scalar" : never) | (T extends boolean ? "boolean" | "scalar" : never) | (T extends number ? "number" | "scalar" : never) | (T extends string ? "string" | "scalar" : never) | (T extends unknown[] ? "array" : never) | (T extends Record<string, unknown> ? "object" : never));

// @public (undocumented)
export type IsOperator = "is" | "is-not";

// @public (undocumented)
export interface ModelBuilder<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Actions extends WriteModel = WriteModel> {
    // (undocumented)
    addAction<ActionKey extends string, Handler extends ActionHandler>(key: ActionKey, handler: Handler): ModelBuilder<Events, Views, Actions & WriteModel<ActionKey, ActionHandler>>;
    // (undocumented)
    addEvent<EventKey extends string, EventArg>(key: EventKey, type: Type<EventArg>): ModelBuilder<Events & ChangeModel<EventKey, EventArg>, Views, Actions>;
    // (undocumented)
    addView<ViewKey extends string, Handler extends Projection>(key: ViewKey, handler: Handler): ModelBuilder<Events, Views & ReadModel<ViewKey, Handler>, Actions>;
    // (undocumented)
    createModel(): DomainModel<Events, Views, Actions>;
}

// @public (undocumented)
export interface Page<T> {
    // (undocumented)
    readonly continuation?: string;
    // (undocumented)
    readonly final?: boolean;
    // (undocumented)
    readonly items: readonly T[];
}

// @public (undocumented)
export interface PageOptions {
    // (undocumented)
    continuation?: string;
    // (undocumented)
    fill?: boolean;
    // (undocumented)
    size?: number;
}

// @public (undocumented)
export type Projection = StateProjection | QueryHandler | EntityProjection;

// @public (undocumented)
export interface Queryable<T> extends SortedQueryable<T> {
    // (undocumented)
    by<P extends keyof SortableProps<T>>(property: P): SortedQueryable<T>;
}

// @public (undocumented)
export type QueryFunc<R extends ReadModel = ReadModel, P extends Record<string, unknown> = Record<string, unknown>, T = unknown> = (view: ViewSnapshot<R>, params: P) => Promise<T>;

// @public (undocumented)
export interface QueryHandler<P extends Record<string, unknown> = Record<string, unknown>, T = unknown, R extends ReadModel = ReadModel> {
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly exec: QueryFunc<R, P, T>;
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    readonly params: Type<P>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export interface QueryView<P = unknown, T = unknown> {
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    query(params: P): T;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type ReadModel<K extends string = string, T extends Projection = Projection> = Readonly<Record<K, T>>;

// @public (undocumented)
export interface ReadonlyEntityCollection<T extends Record<string, unknown> = Record<string, unknown>> extends Queryable<Entity<T>> {
    // (undocumented)
    get(id: number): Promise<Entity<T> | undefined>;
}

// @public (undocumented)
export type SortableProps<T> = {
    [P in keyof T]: T[P] extends Comparable ? T[P] : never;
};

// @public (undocumented)
export interface SortedQueryable<T> extends AsyncIterable<T> {
    // (undocumented)
    any(): Promise<boolean>;
    // (undocumented)
    count(): Promise<number>;
    // (undocumented)
    first(): Promise<T | undefined>;
    // (undocumented)
    page(options?: PageOptions): Promise<Page<T>>;
    // (undocumented)
    where<P extends string & keyof T, O extends FilterOperator<T[P]>>(property: P, operator: O, operand: FilterOperand<T[P], O>): SortedQueryable<T>;
}

// @public (undocumented)
export type StateApplyFunc<C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, T = unknown> = (this: void, change: ChangeType<C>, before: T, view: ViewSnapshot<R>) => Promise<T>;

// @public (undocumented)
export interface StateProjection<T = unknown, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel> {
    // (undocumented)
    readonly apply: StateApplyFunc<C, R, T>;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly initial: T;
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export interface StateView<T = unknown> {
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    read(): Promise<T>;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type StringOperator = ("contains" | "contains-ignore-case" | "starts-with" | "starts-with-ignore-case" | "ends-with" | "ends-with-ignore-case");

// @public (undocumented)
export type VersionAlignment<T> = (T extends number ? ("exact" | "fresh-after" | "fresh-before") : ("latest" | "latest-fresh"));

// @public (undocumented)
export type View = StateView | QueryView | EntityView;

// @public (undocumented)
export type ViewOf<H extends Projection> = H extends StateProjection<infer T> ? StateView<T> : H extends QueryHandler<infer P, infer T> ? QueryView<P, T> : H extends EntityProjection<infer T> ? EntityView<T> : View;

// @public (undocumented)
export interface ViewOptions<T extends number | undefined = undefined> {
    // (undocumented)
    readonly align?: VersionAlignment<T>;
    // (undocumented)
    readonly version?: T;
}

// @public (undocumented)
export type ViewSnapshot<R extends ReadModel> = <K extends string & keyof R>(key: K) => Promise<ViewOf<R[K]>>;

// @public (undocumented)
export type WriteModel<K extends string = string, T extends ActionHandler = ActionHandler> = Readonly<Record<K, T>>;

```

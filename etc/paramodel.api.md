## API Report File for "paramodel"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Type } from 'paratype';
import { TypeOf } from 'paratype';

// @public (undocumented)
export interface AbortOptions {
    // (undocumented)
    signal?: AbortSignal;
    // (undocumented)
    timeout?: number;
}

// @public (undocumented)
export interface Action<D extends ProjectionsDomain, I extends Type<unknown>, O extends Type<unknown> = Type<void>> {
    // (undocumented)
    input: I;
    // (undocumented)
    output?: O;
    // (undocumented)
    run: ActionRunner<D, I, O>;
}

// @public (undocumented)
export interface ActionContext<D extends ProjectionsDomain, T> {
    // (undocumented)
    readonly base: Snapshot<D>;
    // (undocumented)
    readonly commit: Commit<TypeOf<D["meta"]>>;
    // (undocumented)
    conflict(message?: string): never;
    // (undocumented)
    conflict(when: true, message?: string): never;
    // (undocumented)
    conflict(when: false, message?: string): void;
    // (undocumented)
    readonly dry: boolean;
    // (undocumented)
    readonly emit: Emitter<D>;
    // (undocumented)
    readonly input: T;
}

// @public (undocumented)
export interface ActionResult<D extends ProjectionsDomain, T> {
    // (undocumented)
    readonly result: T;
    // (undocumented)
    readonly snapshot: Snapshot<D>;
}

// @public (undocumented)
export type ActionRunner<D extends ProjectionsDomain, I extends Type<unknown>, O extends Type<unknown> = Type<void>> = (context: ActionContext<D, TypeOf<I>>) => Promise<TypeOf<O>>;

// @public (undocumented)
export interface ActionsDomain<M extends Type<unknown> = Type<unknown>, E extends DomainEvents = DomainEvents, P extends DomainProjections<EventsDomain<M, E>> = DomainProjections<EventsDomain<M, E>>, C extends DomainCollections<EventsDomain<M, E>> = DomainCollections<EventsDomain<M, E>>, A extends DomainActions<ProjectionsDomain<M, E, P, C>> = DomainActions<ProjectionsDomain<M, E, P, C>>> extends ProjectionsDomain<M, E, P, C> {
    // (undocumented)
    readonly actions: A;
}

// @public (undocumented)
export interface ActionsDomainBuilder<M extends Type<unknown>, E extends DomainEvents, P extends DomainProjections<EventsDomain<M, E>>, C extends DomainCollections<EventsDomain<M, E>>, A extends DomainActions<ProjectionsDomain<M, E, P, C>> = DomainActions<ProjectionsDomain<M, E, P, C>>> extends ActionsDomain<M, E, P, C, A> {
    // (undocumented)
    addActions<T extends DomainActions<ProjectionsDomain<M, E, P, C>>>(this: void, actions: T): ActionsDomainBuilder<M, E, P, C, A & T>;
    // (undocumented)
    createDomain(this: void): Domain<M, E, P, C, A>;
}

// @public (undocumented)
export interface Batch<D extends ActionsDomain> {
    // (undocumented)
    abort(this: void): void;
    // (undocumented)
    commit(this: void): Promise<Snapshot<D>>;
    // (undocumented)
    do<K extends keyof D["actions"]>(this: void, action: K, input: TypeOf<D["actions"][K]["input"]>): Promise<TypeOf<D["actions"][K]["output"]>>;
}

// @public (undocumented)
export interface Collection<D extends EventsDomain, T extends Type<unknown>> {
    // (undocumented)
    readonly entity: T;
    // (undocumented)
    readonly on: Partial<CollectionHandlers<D, T>>;
}

// @public (undocumented)
export interface CollectionContext<D extends EventsDomain, T extends Type<unknown>, K extends keyof D["events"]> extends QueryableCollection<TypeOf<T>> {
    // (undocumented)
    readonly change: K;
    // (undocumented)
    readonly commit: Commit<TypeOf<D["meta"]>>;
    // (undocumented)
    del(id: number): void;
    // (undocumented)
    readonly input: TypeOf<D["events"][K]>;
    // (undocumented)
    put(id: number, value: TypeOf<T>): void;
}

// @public (undocumented)
export type CollectionFunc<D extends EventsDomain, T extends Type<unknown>, K extends keyof D["events"]> = (this: void, context: CollectionContext<D, T, K>) => Promise<void>;

// @public (undocumented)
export type CollectionHandlers<D extends EventsDomain, T extends Type<unknown>> = {
    [K in keyof D["events"]]: CollectionFunc<D, T, K>;
};

// @public (undocumented)
export interface CollectionView<D extends ProjectionsDomain, K extends keyof D["collections"]> extends QueryableCollection<TypeOf<D["collections"][K]["entity"]>> {
    // (undocumented)
    alloc(): number;
    // (undocumented)
    readonly snapshot: Snapshot<D>;
}

// @public (undocumented)
export interface Commit<M> {
    // (undocumented)
    readonly local: boolean;
    // (undocumented)
    readonly meta: M;
    // (undocumented)
    readonly timestamp: Date;
    // (undocumented)
    readonly version: string;
}

// @public (undocumented)
export interface CommitOptions<M> extends AbortOptions {
    // (undocumented)
    dry: boolean;
    // (undocumented)
    maxAttempts?: number;
    // (undocumented)
    meta?: M;
}

// @public (undocumented)
export interface CommitSearchOptions {
    // (undocumented)
    align?: "exact" | "after" | "before" | "exact-after" | "exact-before";
    // (undocumented)
    timestamp?: Date;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export const createDomainBuilder: () => MetaDomainBuilder<Type<void>>;

// @public (undocumented)
export type Domain<M extends Type<unknown> = Type<unknown>, E extends DomainEvents = DomainEvents, P extends DomainProjections<EventsDomain<M, E>> = DomainProjections<EventsDomain<M, E>>, C extends DomainCollections<EventsDomain<M, E>> = DomainCollections<EventsDomain<M, E>>, A extends DomainActions<ProjectionsDomain<M, E, P, C>> = DomainActions<ProjectionsDomain<M, E, P, C>>> = ActionsDomain<M, E, P, C, A>;

// @public (undocumented)
export type DomainActions<D extends ProjectionsDomain> = Readonly<Record<string, Action<D, Type<unknown>, Type<unknown>>>>;

// @public (undocumented)
export type DomainCollections<D extends EventsDomain> = Readonly<Record<string, Collection<D, Type<unknown>>>>;

// @public (undocumented)
export type DomainEvents = Readonly<Record<string, Type<unknown>>>;

// @public (undocumented)
export type DomainProjections<D extends EventsDomain> = Readonly<Record<string, Projection<D, Type<unknown>>>>;

// @public (undocumented)
export type Emitter<D extends EventsDomain> = {
    [P in keyof D["events"]]: (arg: TypeOf<D["events"][P]>) => void;
};

// @public (undocumented)
export interface EventsDomain<M extends Type<unknown> = Type<unknown>, E extends DomainEvents = DomainEvents> extends MetaDomain<M> {
    // (undocumented)
    readonly events: E;
}

// @public (undocumented)
export interface EventsDomainBuilder<M extends Type<unknown>, E extends DomainEvents> extends EventsDomain<M, E> {
    // (undocumented)
    addActions<T extends DomainActions<ProjectionsDomain<M, E>>>(this: void, actions: T): ActionsDomainBuilder<M, E, DomainProjections<EventsDomain<M, E>>, DomainCollections<EventsDomain<M, E>>, T>;
    // (undocumented)
    addCollections<T extends DomainCollections<EventsDomain<M, E>>>(this: void, collections: T): ProjectionsDomainBuilder<M, E, DomainProjections<EventsDomain<M, E>>, T>;
    // (undocumented)
    addEvents<T extends DomainEvents>(this: void, events: T): EventsDomainBuilder<M, E & T>;
    // (undocumented)
    addProjections<T extends DomainProjections<EventsDomain<M, E>>>(this: void, projections: T): ProjectionsDomainBuilder<M, E, T>;
    // (undocumented)
    createDomain(this: void): Domain<M, E>;
    // (undocumented)
    setupMeta<T extends Type<unknown>>(this: void, type: T): EventsDomainBuilder<T, E>;
}

// @public (undocumented)
export interface EventStore {
    // (undocumented)
    stream<D extends Domain>(this: void, id: string, domain: D): EventStream<D>;
}

// @public (undocumented)
export interface EventStream<D extends Domain> {
    // (undocumented)
    batch(this: void, options?: CommitOptions<TypeOf<D["meta"]>>): Batch<D>;
    // (undocumented)
    do<K extends keyof D["actions"]>(this: void, action: K, input: TypeOf<D["actions"][K]["input"]>, options?: CommitOptions<TypeOf<D["meta"]>>): Promise<ActionResult<D, TypeOf<D["actions"][K]["output"]>>>;
    // (undocumented)
    readonly domain: D;
    // (undocumented)
    entities<K extends keyof D["collections"]>(this: void, key: K, options?: PeekOptions): Promise<CollectionView<D, K>>;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    peek(this: void, options?: PeekOptions): Promise<Snapshot<D> | null>;
    // (undocumented)
    read(this: void, options?: ReadOptions): AsyncIterable<SnapshotData<D>>;
    // (undocumented)
    view<K extends keyof D["projections"]>(this: void, key: K, options?: PeekOptions): Promise<ProjectionView<D, K>>;
}

// @public (undocumented)
export interface MetaDomain<M extends Type<unknown> = Type<unknown>> {
    // (undocumented)
    readonly meta: M;
}

// @public (undocumented)
export interface MetaDomainBuilder<M extends Type<unknown>> extends MetaDomain<M> {
    // (undocumented)
    addEvents<T extends DomainEvents>(this: void, events: T): EventsDomainBuilder<M, T>;
    // (undocumented)
    createDomain(this: void): Domain<M>;
    // (undocumented)
    setupMeta<T extends Type<unknown>>(this: void, type: T): MetaDomainBuilder<T>;
}

// @public (undocumented)
export type PeekOptions = CommitSearchOptions & AbortOptions;

// @public (undocumented)
export interface Projection<D extends EventsDomain, T extends Type<unknown>> {
    // (undocumented)
    init(): TypeOf<T>;
    // (undocumented)
    readonly on: Partial<ProjectionHandlers<D, T>>;
    // (undocumented)
    readonly type: T;
}

// @public (undocumented)
export interface ProjectionContext<E, T, K, M> {
    // (undocumented)
    readonly arg: E;
    // (undocumented)
    readonly before: T;
    // (undocumented)
    readonly change: K;
    // (undocumented)
    readonly commit: Commit<M>;
}

// @public (undocumented)
export type ProjectionFunc<E, T, K, M> = (this: void, context: ProjectionContext<E, T, K, M>) => T;

// @public (undocumented)
export type ProjectionHandlers<D extends EventsDomain, T extends Type<unknown>> = {
    [K in keyof D["events"]]: ProjectionFunc<TypeOf<D["events"][K]>, T, K, TypeOf<D["meta"]>>;
};

// @public (undocumented)
export interface ProjectionsDomain<M extends Type<unknown> = Type<unknown>, E extends DomainEvents = DomainEvents, P extends DomainProjections<EventsDomain<M, E>> = DomainProjections<EventsDomain<M, E>>, C extends DomainCollections<EventsDomain<M, E>> = DomainCollections<EventsDomain<M, E>>> extends EventsDomain<M, E> {
    // (undocumented)
    readonly collections: C;
    // (undocumented)
    readonly projections: P;
}

// @public (undocumented)
export interface ProjectionsDomainBuilder<M extends Type<unknown>, E extends DomainEvents, P extends DomainProjections<EventsDomain<M, E>>, C extends DomainCollections<EventsDomain<M, E>> = DomainCollections<EventsDomain<M, E>>> extends ProjectionsDomain<M, E, P, C> {
    // (undocumented)
    addActions<T extends DomainActions<ProjectionsDomain<M, E, P, C>>>(this: void, actions: T): ActionsDomainBuilder<M, E, P, C, T>;
    // (undocumented)
    addCollections<T extends DomainCollections<EventsDomain<M, E>>>(this: void, collections: T): ProjectionsDomainBuilder<M, E, P, C & T>;
    // (undocumented)
    addProjections<T extends DomainProjections<EventsDomain<M, E>>>(this: void, projections: T): ProjectionsDomainBuilder<M, E, P & T, C>;
    // (undocumented)
    createDomain(this: void): Domain<M, E, P, C>;
}

// @public (undocumented)
export type ProjectionType<P extends Projection<EventsDomain, Type<unknown>>> = P extends Projection<EventsDomain, infer T> ? TypeOf<T> : never;

// @public (undocumented)
export interface ProjectionView<D extends ProjectionsDomain, K extends keyof D["projections"]> {
    // (undocumented)
    readonly key: K;
    // (undocumented)
    readonly snapshot: Snapshot<D>;
    // (undocumented)
    readonly value: ProjectionType<D["projections"][K]>;
}

// Warning: (ae-forgotten-export) The symbol "Queryable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface QueryableCollection<T> extends Queryable<T> {
    // (undocumented)
    get(id: number): Promise<T | undefined>;
}

// @public (undocumented)
export interface ReadOptions extends AbortOptions {
    // (undocumented)
    end?: CommitSearchOptions;
    // (undocumented)
    start?: CommitSearchOptions;
}

// @public (undocumented)
export interface Snapshot<D extends ProjectionsDomain> {
    // (undocumented)
    entities<K extends keyof D["collections"]>(this: void, key: K, options?: AbortOptions): Promise<CollectionView<D, K>>;
    // (undocumented)
    read(this: void): Promise<SnapshotData<D>>;
    // (undocumented)
    view<K extends keyof D["projections"]>(this: void, key: K, options?: AbortOptions): Promise<ProjectionView<D, K>>;
}

// @public (undocumented)
export interface SnapshotData<D extends EventsDomain> {
    // (undocumented)
    readonly changes: ReadonlyArray<[keyof D["events"], D["events"][string]]>;
    // (undocumented)
    readonly commit: Commit<TypeOf<D["meta"]>>;
}

```

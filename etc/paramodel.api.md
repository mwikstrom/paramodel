## API Report File for "paramodel"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ErrorCallback } from 'paratype';
import { JsonValue } from 'paratype';
import { PathArray } from 'paratype';
import { Type } from 'paratype';
import { TypeOf } from 'paratype';

// @public
export interface ActionContext<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> {
    conflict(this: void, message?: string): Conflict;
    emit<K extends string & keyof Events>(this: void, key: K, arg: TypeOf<Events[K]>): void;
    forbidden(this: void, message?: string): Forbidden;
    readonly input: Input;
    output(this: void, result: Output): void;
    pii(this: void, scope: string, value: string, obfuscated?: string): Promise<PiiString>;
    readonly scope: Scope;
    shred(this: void, scope: string): void;
    readonly timestamp: Date;
    readonly version: number;
    view<K extends string & keyof Views>(this: void, key: K, options?: Partial<Pick<ViewOptions, "auth">>): Promise<ViewOf<Views[K]>>;
}

// @public
export interface ActionDefinition<Input, Output, Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Dependencies extends (string & keyof Views)[] = []> {
    dependencies?: Dependencies;
    exec(this: void, context: ActionContext<Events, Views, Scope, Input, Output>): Promise<Forbidden | Conflict | void>;
    input: Type<Input>;
    output?: Type<Output>;
}

// @public
export type ActionFunc<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> = ActionHandler<Events, Views, Scope, Input, Output>["exec"];

// @public
export interface ActionHandler<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> {
    readonly dependencies: ReadonlySet<string & keyof Views>;
    exec(this: void, context: ActionContext<Events, Views, Scope, Input, Output>): Promise<Forbidden | Conflict | void>;
    readonly input: Type<Input>;
    readonly output: Type<Output>;
}

// @public
export interface ActionOptions {
    dry?: boolean;
    signal?: AbortSignal;
}

// @public
export interface ActionResult<Output = unknown> {
    readonly base: number;
    readonly changes?: number;
    readonly committed?: number;
    readonly message?: string;
    readonly output?: Output;
    readonly status: ActionResultStatus;
    readonly timestamp: Date;
}

// @public
export type ActionResultStatus = ("success" | "conflict" | "forbidden" | "aborted" | "rejected" | "failed");

// @public
export type ActionResultType<Model extends Pick<DomainModel, "actions" | "events">, Action extends string & keyof Model["actions"]> = (ActionResult<TypeOf<Model["actions"][Action]["output"]>>);

// @public
export type AnyActionHandler = ActionHandler<any, any, any, any, any>;

// @public
export type AnyProjection = (StateProjection<any, any, any, any> | QueryHandler<any, any, any, any> | EntityProjection<any, any, any, any, any> | EntityMapping<any, any, any, any, any>);

// @public
export type ArrayAnyOperator = ("includes-any" | "not-includes-any");

// @public
export type ArrayOperator = ("includes" | "not-includes" | ArrayAnyOperator);

// @public
export interface Change<T = unknown, K extends string = string> {
    readonly arg: T;
    readonly key: K;
    readonly position: number;
    readonly timestamp: Date;
    readonly version: number;
}

// @public
export type ChangeModel<K extends string = string, T = unknown> = Readonly<Record<K, Type<T>>>;

// @public
export type ChangeType<Model extends ChangeModel> = {
    [K in keyof Model]: K extends string ? Change<TypeOf<Model[K]>, K> : never;
}[keyof Model];

// @public
export type Comparable = number | string | Date;

// @public
export type ComparisonOperator = ">" | ">=" | "<" | "<=";

// @public
export const Conflict: unique symbol;

// @public
export type Conflict = typeof Conflict;

// @public
export function createDomainProvider(this: void, driver: DomainDriver): DomainProvider;

// @public
export function createMemoryDriver(this: void): DomainDriver;

// Warning: (ae-forgotten-export) The symbol "_PiiStringData" needs to be exported by the entry point index.d.ts
//
// @internal (undocumented)
export const _createPiiString: (data: _PiiStringData) => PiiString;

// @public
export function defineAction<Input, Output, Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Dependencies extends (string & keyof Views)[] = []>(this: void, definition: ActionDefinition<Input, Output, Scope, Events, Views, Dependencies>): ActionHandler<Events, Pick<Views, Dependencies[number]>, Scope, Input, Output>;

// @public
export function defineEntity<Props extends Record<string, unknown>, Key extends PossibleKeysOf<Props>, Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Mutators extends (string & keyof Events)[] = [], Dependencies extends (string & keyof Views)[] = []>(this: void, definition: EntityDefinition<Props, Key, Scope, Events, Views, Mutators, Dependencies>): EntityProjection<Props, Key, Events, Views, Scope>;

// @public
export function defineEntityMapping<Props extends Record<string, unknown>, Key extends EntityViews<Views>[Source]["key"], Source extends (string & keyof EntityViews<Views>), Scope = unknown, Views extends ReadModel = ReadModel, Dependencies extends (string & keyof Views)[] = []>(this: void, definition: EntityMappingDefinition<Props, Key, Source, Scope, Views, Dependencies>): EntityMapping<Props, Key, Source, Scope, Views, Dependencies>;

// @public
export function defineQuery<Views extends ReadModel, Result, Params extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, Dependencies extends (string & keyof Views)[] = []>(this: void, definition: QueryDefinition<Views, Result, Params, Scope, Dependencies>): QueryHandler<Params, Result, Pick<Views, Dependencies[number]>, Scope>;

// @public
export function defineState<State, Events extends ChangeModel = ChangeModel, Scope = unknown, Views extends ReadModel = ReadModel, Mutators extends (string & keyof Events)[] = [], Dependencies extends (string & keyof Views)[] = []>(this: void, definition: StateDefinition<State, Events, Scope, Views, Mutators, Dependencies>): StateProjection<State, Events, Views, Scope>;

// @public
export type DisclosedPii<T> = (T extends PiiString ? string : T extends Array<infer E> ? Array<DisclosedPii<E>> : T extends Record<string, any> ? {
    [K in keyof T]: DisclosedPii<T[K]>;
} : T);

// @public
export interface DomainDriver {
    count(this: void, store: string, partition: string, where?: readonly FilterSpec[]): Promise<number>;
    init(this: void, store: string): Promise<void>;
    page(this: void, store: string, partition: string, query?: QuerySpec): Promise<Page<OutputRecord>>;
    read(this: void, store: string, partition: string, key: string): Promise<OutputRecord | undefined>;
    timestamp(this: void): Date;
    write(this: void, store: string, partition: string, input: InputRecord): Promise<OutputRecord | undefined>;
}

// @public
export type DomainModel<Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Actions extends WriteModel = WriteModel> = {
    readonly scope: Type<Scope>;
    readonly events: Events;
    readonly views: Views;
    readonly actions: Actions;
};

// @public
export interface DomainProvider {
    // (undocumented)
    get<Model extends DomainModel>(this: void, id: string, model: Model, scope: TypeOf<Model["scope"]>): Promise<DomainStore<Model>>;
}

// @public
export interface DomainStore<Model extends DomainModel> {
    disclose<T>(this: void, value: T): Promise<DisclosedPii<T>>;
    do<K extends string & keyof Model["actions"]>(this: void, key: K, input: TypeOf<Model["actions"][K]["input"]>, options?: ActionOptions): Promise<ActionResultType<Model, K>>;
    purge(this: void, options?: Partial<PurgeOptions>): Promise<PurgeResult>;
    read(this: void, options?: Partial<ReadOptions<string & keyof Model["events"]>>): AsyncIterable<ChangeType<Model["events"]>>;
    stat(this: void): Promise<DomainStoreStatus>;
    sync<K extends string & keyof Model["views"]>(this: void, options?: Partial<SyncOptions<K>>): Promise<number>;
    view<K extends string & keyof Model["views"]>(this: void, key: K, options?: Partial<ViewOptions>): Promise<ViewOf<Model["views"][K]> | undefined>;
}

// @public
export interface DomainStoreStatus {
    readonly position: number;
    readonly timestamp?: Date;
    readonly version: number;
    readonly views: Readonly<Record<string, ViewStatus>>;
}

// @public
export type EntityAuthFunc<Scope, T, R extends ReadModel = ReadModel> = (query: Queryable<T>, scope: Scope, view: ViewSnapshotFunc<R>) => Promise<Queryable<T> | Forbidden>;

// @public
export type EntityChangeHandlers<Events extends ChangeModel, Props, Key extends PossibleKeysOf<Props>, Views extends ReadModel = ReadModel> = Partial<{
    [E in keyof Events]: EntityProjectionFunc<Props, Key, Change<TypeOf<Events[E]>>, Views>;
}>;

// @public
export interface EntityDefinition<Props extends Record<string, unknown>, Key extends PossibleKeysOf<Props>, Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Mutators extends (string & keyof Events)[] = [], Dependencies extends (string & keyof Views)[] = []> {
    auth?: EntityAuthFunc<Scope, Props, Pick<Views, Dependencies[number]>>;
    dependencies?: Dependencies;
    key: Key;
    mutators: EntityChangeHandlers<Pick<Events, Mutators[number]>, Props, Key, Pick<Views, Dependencies[number]>>;
    type: Type<Props>;
}

// @public
export interface EntityMapping<Props extends Record<string, unknown>, Key extends PossibleKeysOf<Props>, Source extends (string & keyof EntityViews<Views>), Scope = unknown, Views extends ReadModel = ReadModel, Dependencies extends (string & keyof Views)[] = []> {
    // (undocumented)
    auth?: EntityAuthFunc<Scope, Props, Pick<Views, Dependencies[number] | Source>>;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof Views>;
    // (undocumented)
    readonly key: Key;
    // (undocumented)
    readonly kind: "mapped-entities";
    // (undocumented)
    map(source: TypeOf<EntityViews<Views>[Source]["type"]>, disclose: (pii: PiiString) => Promise<string>): Promise<Props>;
    // (undocumented)
    readonly source: Source;
    // (undocumented)
    readonly type: Type<Props>;
}

// @public
export interface EntityMappingDefinition<Props extends Record<string, unknown>, Key extends EntityViews<Views>[Source]["key"], Source extends (string & keyof EntityViews<Views>), Scope = unknown, Views extends ReadModel = ReadModel, Dependencies extends (string & keyof Views)[] = []> {
    auth?: EntityAuthFunc<Scope, Props, Pick<Views, Dependencies[number] | Source>>;
    dependencies?: Dependencies;
    key: Key;
    map(source: TypeOf<EntityViews<Views>[Source]["type"]>, disclose: (pii: PiiString) => Promise<string>): Promise<Props>;
    source: Source;
    type: Type<Props>;
}

// @public
export interface EntityProjection<T extends Record<string, unknown> = Record<string, unknown>, K extends PossibleKeysOf<T> = PossibleKeysOf<T>, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly apply: EntityProjectionFunc<T, K, Change, R>;
    // (undocumented)
    readonly auth: EntityAuthFunc<Scope, T, R> | undefined;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly key: K;
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public
export type EntityProjectionFunc<T, K extends PossibleKeysOf<T>, C extends Change = Change, R extends ReadModel = ReadModel> = (change: C, state: EntityProjectionState<T, K>, view: ViewSnapshotFunc<R>) => Promise<void>;

// @public
export interface EntityProjectionState<T = Record<string, unknown>, K extends PossibleKeysOf<T> = PossibleKeysOf<T>> {
    readonly base: ReadonlyEntityCollection<T, K>;
    del(this: void, key: T[K]): void;
    put(this: void, props: T): void;
}

// @public
export interface EntityView<T extends Record<string, unknown> = Record<string, unknown>, K extends PossibleKeysOf<T> = PossibleKeysOf<T>> extends ReadonlyEntityCollection<T, K> {
    // (undocumented)
    readonly kind: "entities" | "mapped-entities";
    // (undocumented)
    readonly version: number;
}

// @public
export type EntityViews<AllViews extends ReadModel> = {
    [P in keyof AllViews]: AllViews[P] extends EntityProjection ? AllViews[P] : never;
};

// @public
export type EqualityOperator = "==" | "!=" | "in" | "not-in";

// @public
export type Equatable = null | boolean | Comparable;

// @public
export type ErrorFactory = () => Error;

// @public
export type FilterOperand<T, O> = (O extends IsOperator ? IsOperand<T> : O extends EqualityOperator ? T : O extends ComparisonOperator ? T : O extends ArrayAnyOperator ? T : O extends ArrayOperator ? T extends unknown[infer E] ? E : never : O extends StringOperator ? string : never);

// @public
export type FilterOperator<T> = ((IsOperand<T> extends never ? never : IsOperator) | (T extends Equatable ? EqualityOperator : never) | (T extends Comparable ? ComparisonOperator : never) | (T extends readonly unknown[] ? ArrayOperator : never) | (T extends string ? StringOperator : never));

// @public
export interface FilterSpec {
    readonly operand: JsonValue;
    readonly operator: FilterOperator<JsonValue>;
    readonly path: readonly string[];
}

// @public
export const Forbidden: unique symbol;

// @public
export type Forbidden = typeof Forbidden;

// @public
export interface InputRecord {
    readonly key: string;
    readonly replace: string | null;
    readonly ttl: number;
    readonly value: JsonValue;
}

// @public
export type IsOperand<T> = ((T extends undefined ? "defined" : never) | (T extends null ? "null" | "scalar" : never) | (T extends boolean ? "boolean" | "scalar" : never) | (T extends number ? "number" | "scalar" : never) | (T extends string ? "string" | "scalar" : never) | (T extends unknown[] ? "array" : never) | (T extends Record<string, unknown> ? "object" : never));

// @public
export type IsOperator = "is" | "is-not";

// @public
export type OutputRecord = {
    readonly key: string;
    readonly value: JsonValue;
    readonly token: string;
    readonly ttl: number;
    readonly timestamp: number;
};

// @public
export interface Page<T> {
    readonly continuation?: string;
    readonly items: readonly T[];
}

// @public
export interface PageOptions {
    continuation?: string;
    size?: number;
}

// @public
export interface PiiString {
    // @internal (undocumented)
    _getData(): _PiiStringData;
    toJsonValue(error?: ErrorCallback, path?: PathArray): JsonValue;
    toString(): string;
    valueOf(): string;
}

// @public
export const piiStringType: Type<PiiString>;

// @public
export type PossibleKeysOf<T> = {
    [P in keyof T]: T[P] extends (string | number | unknown) ? P extends string ? P : never : never;
}[keyof T];

// @public
export interface PurgeOptions {
    readonly signal: AbortSignal;
}

// @public
export interface PurgeResult {
    readonly done: boolean;
}

// @public
export interface Queryable<T> {
    // (undocumented)
    all(this: void): AsyncIterable<T>;
    // (undocumented)
    any(this: void): Promise<boolean>;
    // (undocumented)
    by<P extends string & keyof SortableProps<T>>(this: void, property: P, direction?: SortDirection): Queryable<T>;
    // (undocumented)
    count(this: void): Promise<number>;
    // (undocumented)
    first(this: void): Promise<T | undefined>;
    // (undocumented)
    page(this: void, options?: PageOptions): Promise<Page<T>>;
    // (undocumented)
    where<P extends string & keyof T, O extends FilterOperator<T[P]>>(this: void, property: P, operator: O, operand: FilterOperand<T[P], O>): Queryable<T>;
}

// @public
export type QueryAuthFunc<R extends ReadModel = ReadModel, P extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, T = unknown> = (this: void, exec: QueryExecFunc<R, P, Scope, T>, view: ViewSnapshotFunc<R>, params: P, scope: Scope) => Promise<T | Forbidden>;

// @public
export interface QueryDefinition<Views extends ReadModel, Result, Params extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, Dependencies extends (string & keyof Views)[] = []> {
    auth?: QueryAuthFunc<Pick<Views, Dependencies[number]>, Params, Scope, Result>;
    dependencies: Dependencies;
    exec: QueryExecFunc<Pick<Views, Dependencies[number]>, Params, Scope, Result>;
    params: Type<Params>;
    type: Type<Result>;
}

// @public
export type QueryExecFunc<R extends ReadModel = ReadModel, P extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, T = unknown> = (this: void, view: ViewSnapshotFunc<R>, params: P, scope: Scope) => Promise<T>;

// @public
export interface QueryHandler<P extends Record<string, unknown> = Record<string, unknown>, T = unknown, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly auth?: QueryAuthFunc<R, P, Scope, T>;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly exec: QueryExecFunc<R, P, Scope, T>;
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    readonly params: Type<P>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public
export interface QuerySpec {
    readonly by?: SortSpec;
    readonly continuation?: string;
    readonly size?: number;
    readonly where?: readonly FilterSpec[];
}

// @public
export interface QueryView<P = unknown, T = unknown> {
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    query(this: void, params: P): Promise<T>;
    // (undocumented)
    readonly version: number;
}

// @public
export type ReadModel<K extends string = string, T extends AnyProjection = AnyProjection> = Readonly<Record<K, T>>;

// @public
export interface ReadonlyEntityCollection<T, K extends PossibleKeysOf<T> = PossibleKeysOf<T>> extends Queryable<T> {
    // (undocumented)
    get(this: void, key: T[K]): Promise<T | undefined>;
}

// @public
export interface ReadOptions<K extends string> {
    readonly excludeFirst: boolean;
    readonly excludeLast: boolean;
    readonly filter: readonly K[];
    readonly first: number;
    readonly last: number;
}

// @public
export type SortableProps<T> = {
    [P in keyof T]: T[P] extends Comparable ? T[P] : never;
};

// @public
export type SortDirection = "ascending" | "descending";

// @public
export interface SortSpec {
    readonly direction: SortDirection;
    readonly path: readonly string[];
}

// @public
export type StateApplyFunc<C extends Change = Change, T = unknown, R extends ReadModel = ReadModel> = (this: void, change: C, before: T, view: ViewSnapshotFunc<R>) => Promise<T>;

// @public
export type StateAuthFunc<Scope = unknown, T = unknown, R extends ReadModel = ReadModel> = (this: void, scope: Scope, state: T, view: ViewSnapshotFunc<R>) => Promise<T | Forbidden>;

// @public
export type StateChangeHandlers<Events extends ChangeModel, State, Views extends ReadModel = ReadModel> = Partial<{
    [K in keyof Events]: StateApplyFunc<Change<TypeOf<Events[K]>>, State, Views>;
}>;

// @public
export interface StateDefinition<State, Events extends ChangeModel = ChangeModel, Scope = unknown, Views extends ReadModel = ReadModel, Mutators extends (string & keyof Events)[] = [], Dependencies extends (string & keyof Views)[] = []> {
    auth?: StateAuthFunc<Scope, State, Pick<Views, Dependencies[number]>>;
    dependencies?: Dependencies;
    initial: State;
    mutators: StateChangeHandlers<Pick<Events, Mutators[number]>, State, Pick<Views, Dependencies[number]>>;
    type: Type<State>;
}

// @public
export interface StateProjection<T = unknown, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly apply: StateApplyFunc<Change, T, R>;
    // (undocumented)
    readonly auth: StateAuthFunc<Scope, T, R> | undefined;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly initial: T;
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public
export interface StateView<T = unknown> {
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    read(this: void): Promise<T>;
    // (undocumented)
    readonly version: number;
}

// @public
export type StringOperator = ("equals-ignore-case" | "contains" | "contains-ignore-case" | "starts-with" | "starts-with-ignore-case" | "ends-with" | "ends-with-ignore-case" | "not-equals-ignore-case" | "not-contains" | "not-contains-ignore-case" | "not-starts-with" | "not-starts-with-ignore-case" | "not-ends-with" | "not-ends-with-ignore-case");

// @public
export interface SyncOptions<K extends string = string> {
    readonly signal: AbortSignal;
    readonly target: number;
    readonly views: readonly K[];
}

// @public
export type TransparentPii<T> = (T extends string ? string | PiiString : T extends Array<infer E> ? Array<TransparentPii<E>> : T extends Record<string, any> ? {
    [K in keyof T]: TransparentPii<T[K]>;
} : T);

// @public
export type View = StateView | QueryView | EntityView<Record<string, string | number>, string>;

// @public
export type ViewOf<H extends AnyProjection> = H extends StateProjection<infer T, any, any, any> ? StateView<T> : H extends QueryHandler<infer P, infer T, any, any> ? QueryView<P, T> : H extends EntityProjection<infer T, infer K, any, any, any> ? EntityView<T, K> : H extends EntityMapping<infer T, infer K, any, any, any, any> ? EntityView<T, K> : View;

// @public
export interface ViewOptions {
    readonly auth: boolean | ErrorFactory;
    readonly signal: AbortSignal;
    readonly sync: number;
}

// @public
export type ViewSnapshotFunc<R extends ReadModel> = <K extends string & keyof R>(this: void, key: K, options?: Partial<Pick<ViewOptions, "auth">>) => Promise<ViewOf<R[K]>>;

// @public
export interface ViewStatus {
    readonly last_change_timestamp?: Date;
    readonly last_change_version: number;
    readonly purged_from_version: number;
    readonly purged_until_version: number;
    readonly sync_position: number;
    readonly sync_timestamp?: Date;
    readonly sync_version: number;
}

// @public
export type WriteModel<K extends string = string, T extends ActionHandler = AnyActionHandler> = Readonly<Record<K, T>>;

```

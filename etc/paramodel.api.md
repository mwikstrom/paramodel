## API Report File for "paramodel"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { JsonValue } from 'paratype';
import { Type } from 'paratype';
import { TypeOf } from 'paratype';

// @public
export interface ActionContext<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> {
    conflict(this: void, message?: string): Conflict;
    emit<K extends string & keyof Events>(this: void, key: K, arg: TypeOf<Events[K]>): void;
    forbidden(this: void, message?: string): Forbidden;
    readonly input: Input;
    output(this: void, result: Output): void;
    readonly scope: Scope;
    readonly timestamp: Date;
    readonly version: number;
    view<K extends string & keyof Views>(this: void, key: K, options?: Partial<Pick<ViewOptions, "auth">>): Promise<ViewOf<Views[K]>>;
}

// @public
export type ActionFunc<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> = ActionHandler<Events, Views, Scope, Input, Output>["exec"];

// @public
export interface ActionHandler<Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Scope = unknown, Input = unknown, Output = unknown> {
    readonly dependencies: ReadonlySet<string & keyof Views>;
    exec(this: void, context: ActionContext<Events, Views, Scope, Input, Output>): Promise<Forbidden | Conflict | void>;
    readonly input: Type<Input>;
    readonly output: Type<Output>;
}

// @public (undocumented)
export interface ActionOptions {
    // (undocumented)
    readonly dry: boolean;
    // (undocumented)
    readonly signal: AbortSignal;
}

// @public (undocumented)
export interface ActionResult<Output = unknown> {
    // (undocumented)
    readonly base: number;
    // (undocumented)
    readonly changes?: number;
    // (undocumented)
    readonly committed?: number;
    // (undocumented)
    readonly message?: string;
    // (undocumented)
    readonly output?: Output;
    // (undocumented)
    readonly status: "success" | "conflict" | "forbidden" | "aborted" | "rejected" | "failed";
    // (undocumented)
    readonly timestamp: Date;
}

// @public (undocumented)
export type ActionResultType<Model extends Pick<DomainModel, "actions" | "events">, Action extends string & keyof Model["actions"]> = (ActionResult<TypeOf<Model["actions"][Action]["output"]>>);

// @public
export type AnyActionHandler = ActionHandler<any, any, any, any, any>;

// @public (undocumented)
export type AnyProjection = (StateProjection<any, any, any, any> | QueryHandler<any, any, any, any> | EntityProjection<any, any, any, any, any>);

// @public (undocumented)
export type ArrayAnyOperator = ("includes-any" | "not-includes-any");

// @public (undocumented)
export type ArrayOperator = ("includes" | "not-includes" | ArrayAnyOperator);

// @public (undocumented)
export interface Change<T = unknown, K extends string = string> {
    // (undocumented)
    readonly arg: T;
    // (undocumented)
    readonly key: K;
    // (undocumented)
    readonly position: number;
    // (undocumented)
    readonly timestamp: Date;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type ChangeModel<K extends string = string, T = unknown> = Readonly<Record<K, Type<T>>>;

// @public (undocumented)
export type ChangeType<Model extends ChangeModel> = {
    [K in keyof Model]: K extends string ? Change<TypeOf<Model[K]>, K> : never;
}[keyof Model];

// @public (undocumented)
export type Comparable = number | string | Date;

// @public (undocumented)
export type ComparisonOperator = ">" | ">=" | "<" | "<=";

// @public (undocumented)
export const Conflict: unique symbol;

// @public (undocumented)
export type Conflict = typeof Conflict;

// @public (undocumented)
export function createDomainProvider(driver: DomainDriver): DomainProvider;

// @public (undocumented)
export function createMemoryDriver(): DomainDriver;

// @public (undocumented)
export function defineAction<Input, Output, Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Dependencies extends (string & keyof Views)[] = []>(input: Type<Input>, exec: ActionFunc<Events, Pick<Views, Dependencies[number]>, Scope, Input, Output>, dependencies?: Dependencies, output?: Type<Output>): ActionHandler<Events, Pick<Views, Dependencies[number]>, Scope, Input, Output>;

// @public (undocumented)
export function defineEntity<Props extends Record<string, unknown>, Key extends PossibleKeysOf<Props>, Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Mutators extends (string & keyof Events)[] = [], Dependencies extends (string & keyof Views)[] = []>(type: Type<Props>, key: Key, on: {
    [K in Mutators[number]]: (EntityProjectionFunc<Props, Key, Change<TypeOf<Events[K]>, K>, Pick<Views, Dependencies[number]>>);
}, auth?: EntityAuthFunc<Scope, Props, Pick<Views, Dependencies[number]>>, dependencies?: Dependencies): EntityProjection<Props, Key, Events, Views, Scope>;

// @public (undocumented)
export function defineQuery<Views extends ReadModel, Result, Params extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, Dependencies extends (string & keyof Views)[] = []>(type: Type<Result>, params: Type<Params>, dependencies: Dependencies, exec: QueryExecFunc<Pick<Views, Dependencies[number]>, Params, Scope, Result>, auth?: QueryAuthFunc<Pick<Views, Dependencies[number]>, Params, Scope, Result>): QueryHandler<Params, Result, Pick<Views, Dependencies[number]>, Scope>;

// @public (undocumented)
export function defineState<State, Events extends ChangeModel = ChangeModel, Scope = unknown, Views extends ReadModel = ReadModel, Mutators extends (string & keyof Events)[] = [], Dependencies extends (string & keyof Views)[] = []>(type: Type<State>, initial: State, on: {
    [K in Mutators[number]]: StateApplyFunc<Change<Events[K], K>, State, Pick<Views, Dependencies[number]>>;
}, dependencies?: Dependencies, auth?: StateAuthFunc<Scope, State, Pick<Views, Dependencies[number]>>): StateProjection<State, Events, Views, Scope>;

// @public (undocumented)
export interface DomainDriver {
    // (undocumented)
    count(this: void, store: string, partition: string, where?: readonly FilterSpec[]): Promise<number>;
    // (undocumented)
    init(this: void, store: string): Promise<void>;
    // (undocumented)
    page(this: void, store: string, partition: string, query?: QuerySpec): Promise<Page<OutputRecord>>;
    // (undocumented)
    read(this: void, store: string, partition: string, key: string): Promise<OutputRecord | undefined>;
    // (undocumented)
    timestamp(this: void): Date;
    // (undocumented)
    write(this: void, store: string, partition: string, input: InputRecord): Promise<OutputRecord | undefined>;
}

// @public (undocumented)
export type DomainModel<Scope = unknown, Events extends ChangeModel = ChangeModel, Views extends ReadModel = ReadModel, Actions extends WriteModel = WriteModel> = {
    readonly scope: Type<Scope>;
    readonly events: Events;
    readonly views: Views;
    readonly actions: Actions;
};

// @public (undocumented)
export interface DomainProvider {
    // (undocumented)
    get<Model extends DomainModel>(this: void, id: string, model: Model, scope: TypeOf<Model["scope"]>): Promise<DomainStore<Model>>;
}

// @public (undocumented)
export interface DomainStore<Model extends DomainModel> {
    // (undocumented)
    do<K extends string & keyof Model["actions"]>(this: void, key: K, input: TypeOf<Model["actions"][K]["input"]>, options?: Partial<ActionOptions>): Promise<ActionResultType<Model, K>>;
    // (undocumented)
    purge(this: void, options?: Partial<PurgeOptions>): Promise<PurgeResult>;
    // (undocumented)
    read(this: void, options?: Partial<ReadOptions<string & keyof Model["events"]>>): AsyncIterable<ChangeType<Model["events"]>>;
    // (undocumented)
    stat(this: void): Promise<DomainStoreStatus>;
    // (undocumented)
    sync<K extends string & keyof Model["views"]>(this: void, options?: Partial<SyncOptions<K>>): Promise<number>;
    // (undocumented)
    view<K extends string & keyof Model["views"]>(this: void, key: K, options?: Partial<ViewOptions>): Promise<ViewOf<Model["views"][K]> | undefined>;
}

// @public (undocumented)
export interface DomainStoreStatus {
    // (undocumented)
    readonly position: number;
    // (undocumented)
    readonly timestamp?: Date;
    // (undocumented)
    readonly version: number;
    // (undocumented)
    readonly views: Readonly<Record<string, ViewStatus>>;
}

// @public (undocumented)
export type EntityAuthFunc<Scope, T, R extends ReadModel = ReadModel> = (query: Queryable<T>, scope: Scope, view: ViewSnapshotFunc<R>) => Promise<Queryable<T> | Forbidden>;

// @public (undocumented)
export type EntityChangeHandlers<C extends ChangeModel, T, K extends PossibleKeysOf<T>, R extends ReadModel = ReadModel> = Partial<{
    [E in keyof C]: EntityProjectionFunc<T, K, Change<TypeOf<C[E]>>, R>;
}>;

// @public (undocumented)
export interface EntityProjection<T extends Record<string, unknown> = Record<string, unknown>, K extends PossibleKeysOf<T> = PossibleKeysOf<T>, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly apply: EntityProjectionFunc<T, K, Change, R>;
    // (undocumented)
    readonly auth: EntityAuthFunc<Scope, T, R> | undefined;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly key: K;
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export type EntityProjectionFunc<T, K extends PossibleKeysOf<T>, C extends Change = Change, R extends ReadModel = ReadModel> = (change: C, state: EntityProjectionState<T, K>, view: ViewSnapshotFunc<R>) => Promise<void>;

// @public (undocumented)
export interface EntityProjectionState<T = Record<string, unknown>, K extends PossibleKeysOf<T> = PossibleKeysOf<T>> {
    // (undocumented)
    readonly base: ReadonlyEntityCollection<T, K>;
    // (undocumented)
    del(this: void, key: T[K]): void;
    // (undocumented)
    put(this: void, props: T): void;
}

// @public (undocumented)
export interface EntityView<T extends Record<string, unknown> = Record<string, unknown>, K extends PossibleKeysOf<T> = PossibleKeysOf<T>> extends ReadonlyEntityCollection<T, K> {
    // (undocumented)
    readonly kind: "entities";
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type EqualityOperator = "==" | "!=" | "in" | "not-in";

// @public (undocumented)
export type Equatable = null | boolean | Comparable;

// @public (undocumented)
export type ErrorFactory = () => Error;

// @public (undocumented)
export type FilterOperand<T, O> = (O extends IsOperator ? IsOperand<T> : O extends EqualityOperator ? T : O extends ComparisonOperator ? T : O extends ArrayAnyOperator ? T : O extends ArrayOperator ? T extends unknown[infer E] ? E : never : O extends StringOperator ? string : never);

// @public (undocumented)
export type FilterOperator<T> = ((IsOperand<T> extends never ? never : IsOperator) | (T extends Equatable ? EqualityOperator : never) | (T extends Comparable ? ComparisonOperator : never) | (T extends readonly unknown[] ? ArrayOperator : never) | (T extends string ? StringOperator : never));

// @public (undocumented)
export interface FilterSpec {
    // (undocumented)
    readonly operand: JsonValue;
    // (undocumented)
    readonly operator: FilterOperator<JsonValue>;
    // (undocumented)
    readonly path: readonly string[];
}

// @public (undocumented)
export const Forbidden: unique symbol;

// @public (undocumented)
export type Forbidden = typeof Forbidden;

// @public (undocumented)
export interface InputRecord {
    // (undocumented)
    readonly key: string;
    // (undocumented)
    readonly replace: string | null;
    // (undocumented)
    readonly ttl: number;
    // (undocumented)
    readonly value: JsonValue;
}

// @public (undocumented)
export type IsOperand<T> = ((T extends undefined ? "defined" : never) | (T extends null ? "null" | "scalar" : never) | (T extends boolean ? "boolean" | "scalar" : never) | (T extends number ? "number" | "scalar" : never) | (T extends string ? "string" | "scalar" : never) | (T extends unknown[] ? "array" : never) | (T extends Record<string, unknown> ? "object" : never));

// @public (undocumented)
export type IsOperator = "is" | "is-not";

// @public (undocumented)
export type OutputRecord = {
    readonly key: string;
    readonly value: JsonValue;
    readonly token: string;
    readonly ttl: number;
    readonly timestamp: number;
};

// @public (undocumented)
export interface Page<T> {
    // (undocumented)
    readonly continuation?: string;
    // (undocumented)
    readonly items: readonly T[];
}

// @public (undocumented)
export interface PageOptions {
    // (undocumented)
    continuation?: string;
    // (undocumented)
    size?: number;
}

// @public (undocumented)
export type PossibleKeysOf<T> = {
    [P in keyof T]: T[P] extends (string | number | unknown) ? P extends string ? P : never : never;
}[keyof T];

// @public (undocumented)
export interface PurgeOptions {
    // (undocumented)
    readonly signal: AbortSignal;
}

// @public (undocumented)
export interface PurgeResult {
    // (undocumented)
    readonly done: boolean;
}

// @public (undocumented)
export interface Queryable<T> {
    // (undocumented)
    all(this: void): AsyncIterable<T>;
    // (undocumented)
    any(this: void): Promise<boolean>;
    // (undocumented)
    by<P extends string & keyof SortableProps<T>>(this: void, property: P, direction?: SortDirection): Queryable<T>;
    // (undocumented)
    count(this: void): Promise<number>;
    // (undocumented)
    first(this: void): Promise<T | undefined>;
    // (undocumented)
    page(this: void, options?: PageOptions): Promise<Page<T>>;
    // (undocumented)
    where<P extends string & keyof T, O extends FilterOperator<T[P]>>(this: void, property: P, operator: O, operand: FilterOperand<T[P], O>): Queryable<T>;
}

// @public (undocumented)
export type QueryAuthFunc<R extends ReadModel = ReadModel, P extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, T = unknown> = (this: void, exec: QueryExecFunc<R, P, Scope, T>, view: ViewSnapshotFunc<R>, params: P, scope: Scope) => Promise<T | Forbidden>;

// @public (undocumented)
export type QueryExecFunc<R extends ReadModel = ReadModel, P extends Record<string, unknown> = Record<string, unknown>, Scope = unknown, T = unknown> = (this: void, view: ViewSnapshotFunc<R>, params: P, scope: Scope) => Promise<T>;

// @public (undocumented)
export interface QueryHandler<P extends Record<string, unknown> = Record<string, unknown>, T = unknown, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly auth?: QueryAuthFunc<R, P, Scope, T>;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly exec: QueryExecFunc<R, P, Scope, T>;
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    readonly params: Type<P>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export interface QuerySpec {
    // (undocumented)
    readonly by?: SortSpec;
    // (undocumented)
    readonly continuation?: string;
    // (undocumented)
    readonly size?: number;
    // (undocumented)
    readonly where?: readonly FilterSpec[];
}

// @public (undocumented)
export interface QueryView<P = unknown, T = unknown> {
    // (undocumented)
    readonly kind: "query";
    // (undocumented)
    query(this: void, params: P): Promise<T>;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type ReadModel<K extends string = string, T extends AnyProjection = AnyProjection> = Readonly<Record<K, T>>;

// @public (undocumented)
export interface ReadonlyEntityCollection<T, K extends PossibleKeysOf<T> = PossibleKeysOf<T>> extends Queryable<T> {
    // (undocumented)
    get(this: void, key: T[K]): Promise<T | undefined>;
}

// @public (undocumented)
export interface ReadOptions<K extends string> {
    // (undocumented)
    readonly excludeFirst: boolean;
    // (undocumented)
    readonly excludeLast: boolean;
    // (undocumented)
    readonly filter: readonly K[];
    // (undocumented)
    readonly first: number;
    // (undocumented)
    readonly last: number;
}

// @public (undocumented)
export type SortableProps<T> = {
    [P in keyof T]: T[P] extends Comparable ? T[P] : never;
};

// @public (undocumented)
export type SortDirection = "ascending" | "descending";

// @public (undocumented)
export interface SortSpec {
    // (undocumented)
    readonly direction: SortDirection;
    // (undocumented)
    readonly path: readonly string[];
}

// @public (undocumented)
export type StateApplyFunc<C extends Change = Change, T = unknown, R extends ReadModel = ReadModel> = (this: void, change: C, before: T, view: ViewSnapshotFunc<R>) => Promise<T>;

// @public (undocumented)
export type StateAuthFunc<Scope = unknown, T = unknown, R extends ReadModel = ReadModel> = (this: void, scope: Scope, state: T, view: ViewSnapshotFunc<R>) => Promise<T | Forbidden>;

// @public (undocumented)
export type StateChangeHandlers<C extends ChangeModel, T, R extends ReadModel = ReadModel> = Partial<{
    [K in keyof C]: StateApplyFunc<Change<TypeOf<C[K]>>, T, R>;
}>;

// @public (undocumented)
export interface StateProjection<T = unknown, C extends ChangeModel = ChangeModel, R extends ReadModel = ReadModel, Scope = unknown> {
    // (undocumented)
    readonly apply: StateApplyFunc<Change, T, R>;
    // (undocumented)
    readonly auth: StateAuthFunc<Scope, T, R> | undefined;
    // (undocumented)
    readonly dependencies: ReadonlySet<string & keyof R>;
    // (undocumented)
    readonly initial: T;
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    readonly mutators: ReadonlySet<string & keyof C>;
    // (undocumented)
    readonly type: Type<T>;
}

// @public (undocumented)
export interface StateView<T = unknown> {
    // (undocumented)
    readonly kind: "state";
    // (undocumented)
    read(this: void): Promise<T>;
    // (undocumented)
    readonly version: number;
}

// @public (undocumented)
export type StringOperator = ("equals-ignore-case" | "contains" | "contains-ignore-case" | "starts-with" | "starts-with-ignore-case" | "ends-with" | "ends-with-ignore-case" | "not-equals-ignore-case" | "not-contains" | "not-contains-ignore-case" | "not-starts-with" | "not-starts-with-ignore-case" | "not-ends-with" | "not-ends-with-ignore-case");

// @public (undocumented)
export interface SyncOptions<K extends string = string> {
    // (undocumented)
    readonly signal: AbortSignal;
    // (undocumented)
    readonly target: number;
    // (undocumented)
    readonly views: readonly K[];
}

// @public (undocumented)
export type View = StateView | QueryView | EntityView<Record<string, string | number>, string>;

// @public (undocumented)
export type ViewOf<H extends AnyProjection> = H extends StateProjection<infer T, any, any, any> ? StateView<T> : H extends QueryHandler<infer P, infer T, any, any> ? QueryView<P, T> : H extends EntityProjection<infer T, infer K, any, any, any> ? EntityView<T, K> : View;

// @public (undocumented)
export interface ViewOptions {
    // (undocumented)
    readonly auth: boolean | ErrorFactory;
    // (undocumented)
    readonly signal: AbortSignal;
    // (undocumented)
    readonly sync: number;
}

// @public (undocumented)
export type ViewSnapshotFunc<R extends ReadModel> = <K extends string & keyof R>(this: void, key: K, options?: Partial<Pick<ViewOptions, "auth">>) => Promise<ViewOf<R[K]>>;

// @public (undocumented)
export interface ViewStatus {
    // (undocumented)
    readonly last_change_timestamp?: Date;
    // (undocumented)
    readonly last_change_version: number;
    // (undocumented)
    readonly purged_from_version: number;
    // (undocumented)
    readonly purged_until_version: number;
    // (undocumented)
    readonly sync_position: number;
    // (undocumented)
    readonly sync_timestamp?: Date;
    // (undocumented)
    readonly sync_version: number;
}

// @public (undocumented)
export type WriteModel<K extends string = string, T extends ActionHandler = AnyActionHandler> = Readonly<Record<K, T>>;

```
